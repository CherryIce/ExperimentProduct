//
//  RPImage.swift
//  ExperimentProduct
//
//  Created by hubin on 2021/9/18.
//

import UIKit
import AVFoundation

// ÂÉèÁ¥†ÔºåÊØè‰∏™ÂÉèÁ¥†ÂåÖÂê´Á∫¢ÔºåËìùÔºåÁªøÔºåÈÄèÊòéÂ∫¶
public struct CWPixel {
    // ÂÆåÊï¥ÂÉèÁ¥†ÂÄº
    var value: UInt32
    
    // Á∫¢Ëâ≤ÂÄº
    var red: UInt8 {
        get {
            return UInt8(value & 0xFF)
        }
        set {
            value = UInt32(newValue) | (value & 0xFFFFFF00)
        }
    }
    
    // ÁªøËâ≤
    var green: UInt8 {
        get {
            return UInt8((value >> 8) & 0xFF)
        }
        set {
            value = (UInt32(newValue) << 8) | (value & 0xFFFF00FF)
        }
    }
    
    // ËìùËâ≤
    var blue: UInt8 {
        get {
            return UInt8((value >> 16) & 0xFF)
        }
        set {
            value = (UInt32(newValue) << 16) | (value & 0xFF00FFFF)
        }
    }
    
    // ÈÄèÊòé
    var alpha: UInt8 {
        get {
            return UInt8((value >> 24) & 0xFF)
        }
        set {
            value = (UInt32(newValue) << 24) | (value & 0x00FFFFFF)
        }
    }
    
    // ÊòØÂê¶‰∏∫ÁôΩËâ≤
    var isWhite: Bool {
        get {
            return value == 0xFFFFFFFF
        }
    }
}

class RPImage: UIImage {
    //ÂØºËà™Ê†èËøîÂõûÊåâÈíÆÂõæ
    open class var NavBackImage : UIImage {
        get {
            return UIImage.loadImage("back")!
        }
    }
    //ÈªòËÆ§Â§¥ÂÉè
    open class var UserAvatarImage : UIImage {
        get {
            return UIImage.loadImage("ÁªÑ 1894")!
        }
    }
}

extension UIImage {
    //ÂõæÁâáÂàáÂúÜ
    func roundedCornerImageWithCornerRadius(_ cornerRadius:CGFloat) -> UIImage {
        let w = self.size.width
        let h = self.size.height
        
        var targetCornerRadius = cornerRadius
        if cornerRadius < 0 {
            targetCornerRadius = 0
        }
        
        if cornerRadius > min(w, h) {
            targetCornerRadius = min(w,h)
        }
        
        let imageFrame = CGRect(x: 0, y: 0, width: w, height: h)
        
        UIGraphicsBeginImageContextWithOptions(self.size, false, UIScreen.main.scale)
        
        UIBezierPath(roundedRect: imageFrame, cornerRadius: targetCornerRadius).addClip()
        
        self.draw(in: imageFrame)
        
        let image = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        return image!
    }
    
    // Êõ¥ÊîπÂõæÁâáÈ¢úËâ≤
    public func changeColor(_ color : UIColor) -> UIImage{
        
        UIGraphicsBeginImageContextWithOptions(self.size, false, self.scale)
        
        color.setFill()
        
        let bounds = CGRect.init(x: 0, y: 0, width: self.size.width, height: self.size.height)
        
        UIRectFill(bounds)
        
        self.draw(in: bounds, blendMode: CGBlendMode.destinationIn, alpha: 1.0)
        
        let tintedImage = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        
        guard let image = tintedImage else {
            return UIImage()
        }
        return image
    }
    
    //Âä†ËΩΩÂõæÁâá
    static func loadImage(_ imageName: String) -> UIImage? {

        if imageName.isEmpty || imageName.count == 0 {
            return nil
        }

        let nameAndType = imageName.components(separatedBy: ".")
        var name = nameAndType.first!
        let type = nameAndType.count > 1 ? nameAndType[1] : "png"

//        if let image = RPCache.shared.cache?.object(forKey: name) {
//            return image as? UIImage
//        }

        var imagePath = Bundle.main.path(forResource: imageName, ofType: type)
        var isImageUnder3x = false
        let nameLength = name.count

        if imagePath == nil && name.hasSuffix("@") && nameLength > 3 {
            let index = name.index(name.endIndex, offsetBy: -3)
            name = String(name[name.startIndex..<index])
        }

        if imagePath == nil && !name.hasSuffix("@2x") {
            let name2x = name + "@2x"
            imagePath = Bundle.main.path(forResource:name2x, ofType: type)
            if imagePath == nil && !name.hasSuffix("3x") {
                let name3x = name + "@3x"
                imagePath = Bundle.main.path(forResource:name3x, ofType: type)
                isImageUnder3x = true
            }
        }

        var image: UIImage?
        if let imagePath = imagePath {
            image = UIImage(contentsOfFile: imagePath)
        } else {
            //Êúâ‰∏ÄËØ¥‰∏Ä Ëøô‰∏ÄÊ≠•‰∏çÊòØÂæàÂª∫ËÆÆËøô‰πàÂÅö...üòÇ
            if name.hasSuffix("@") && nameLength > 3 {
                let index = name.index(name.endIndex, offsetBy: -3)
                name = String(name[name.startIndex..<index])
            }
            image = UIImage(named: name)
        }
        if #available(iOS 8, *){} else {
            if isImageUnder3x {
                image = image?.scaledImageFrom3x()
            }
        }
//        if let image = image {
//            RPCache.shared.cache?.setObject(image, forKey: name)
//        }
        return image
    }

    func scaledImageFrom3x() -> UIImage {
        let theRate: CGFloat = 1.0 / 3.0
        let oldSize = self.size
        let scaleWidth = CGFloat(oldSize.width) * theRate
        let scaleHeight = CGFloat(oldSize.height) * theRate
        var scaleRect = CGRect.zero
        scaleRect.size = CGSize(width: scaleWidth, height: scaleHeight)
        UIGraphicsBeginImageContextWithOptions(scaleRect.size, false, UIScreen.main.scale)
        draw(in: scaleRect)
        let newImage = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()
        return newImage
    }
    
    // MARK: 1.3„ÄÅËé∑ÂèñËßÜÈ¢ëÁöÑÁ¨¨‰∏ÄÂ∏ß
    /// Ëé∑ÂèñËßÜÈ¢ëÁöÑÁ¨¨‰∏ÄÂ∏ß
    /// - Parameters:
    ///   - videoUrl: ËßÜÈ¢ë url
    ///   - maximumSize: ÂõæÁâáÁöÑÊúÄÂ§ßÂ∞∫ÂØ∏
    /// - Returns: ËßÜÈ¢ëÁöÑÁ¨¨‰∏ÄÂ∏ß
    func getVideoFirstImage(videoUrl: String, maximumSize: CGSize = CGSize(width: 1000, height: 1000), closure: @escaping (UIImage?) -> Void) {
        if videoUrl.isEmpty {
            DispatchQueue.main.async {
                closure(nil)
            }
            return
        }
        let cahce =  RPCache.shared.cache
        if cahce?.object(forKey: videoUrl) != nil {
            let  x = cahce?.object(forKey: videoUrl) as? UIImage
            DispatchQueue.main.async {
                closure(x)
            }
            return
        }
        guard let url = URL(string: videoUrl) else {
            closure(nil)
            return
        }
        DispatchQueue.global().async {
            let opts = [AVURLAssetPreferPreciseDurationAndTimingKey: false]
            let avAsset = AVURLAsset(url: url, options: opts)
            let generator = AVAssetImageGenerator(asset: avAsset)
            generator.appliesPreferredTrackTransform = true
            generator.maximumSize = maximumSize
            var cgImage: CGImage? = nil
            let time = CMTimeMake(value: 0, timescale: 600)
            var actualTime : CMTime = CMTimeMake(value: 0, timescale: 0)
            do {
                try cgImage = generator.copyCGImage(at: time, actualTime: &actualTime)
            } catch {
                DispatchQueue.main.async {
                    closure(nil)
                }
                return
            }
            guard let image = cgImage else {
                DispatchQueue.main.async {
                    closure(nil)
                }
                return
            }
            DispatchQueue.main.async {
                let final = UIImage(cgImage: image)
                cahce?.setObject(final, forKey: videoUrl)
                closure(final)
            }
        }
    }
    
    /// ÁªôÂõæÁâáÊ∑ªÂä†ÊñáÂ≠óÊ∞¥Âç∞
    ///   - drawTextframe: Ê∞¥Âç∞ÁöÑ frame
    ///   - drawText: Ê∞¥Âç∞ÊñáÂ≠ó
    ///   - withAttributes: Ê∞¥Âç∞ÂØåÊñáÊú¨
    /// - Returns: ËøîÂõûÊ∞¥Âç∞ÂõæÁâá
    func drawTextInImage(drawTextframe: CGRect, drawText: String, withAttributes: [NSAttributedString.Key : Any]? = nil) -> UIImage {
        // ÂºÄÂêØÂõæÁâá‰∏ä‰∏ãÊñá
        UIGraphicsBeginImageContext(self.size)
        // ÂõæÂΩ¢ÈáçÁªò
        self.draw(in: CGRect(x: 0, y: 0, width: self.size.width, height: self.size.height))
        // Ê∞¥Âç∞ÊñáÂ≠óÂ±ûÊÄß
        let attributes = withAttributes
        // Ê∞¥Âç∞ÊñáÂ≠óÂíåÂ§ßÂ∞è
        let text = NSString(string: drawText)
        // Ëé∑ÂèñÂØåÊñáÊú¨ÁöÑ size
        // let size = text.size(withAttributes: attributes)
        // ÁªòÂà∂ÊñáÂ≠ó
        text.draw(in: drawTextframe, withAttributes: attributes)
        // ‰ªéÂΩìÂâç‰∏ä‰∏ãÊñáËé∑ÂèñÂõæÁâá
        let image = UIGraphicsGetImageFromCurrentImageContext()
        // ÂÖ≥Èó≠‰∏ä‰∏ãÊñá
        UIGraphicsEndImageContext()
        
        return image!
    }
    
    //Êù°ÂΩ¢Á†Å
    class func createCode128(codeString: String, size: CGSize, qrColor: UIColor, bkColor: UIColor) -> UIImage? {
        let stringData = codeString.data(using: String.Encoding.utf8)
        //CICode128BarcodeGenerator Êù°ÂΩ¢Á†Å
        let qrFilter = CIFilter(name: "CICode128BarcodeGenerator")
        qrFilter?.setDefaults()
        qrFilter?.setValue(stringData, forKey: "inputMessage")
        
        guard let outputImage = qrFilter?.outputImage else {
            return nil
        }
        // ‰∏äËâ≤
        let colorFilter = CIFilter(name: "CIFalseColor",
                                   parameters: [
                                    "inputImage": outputImage,
                                    "inputColor0": CIColor(cgColor: qrColor.cgColor),
                                    "inputColor1": CIColor(cgColor: bkColor.cgColor),
                                   ]
        )
        
        guard let qrImage = colorFilter?.outputImage,
              let cgImage = CIContext().createCGImage(qrImage, from: qrImage.extent) else {
                  return nil
              }
        let image = UIImage(cgImage: cgImage, scale: 1.0, orientation: UIImage.Orientation.up)
        
        // Resize without interpolating
        return resizeImage(image: image, quality: CGInterpolationQuality.none, rate: 20.0)
    }
    
    //ÂõæÂÉèÁº©Êîæ
    class func resizeImage(image: UIImage, quality: CGInterpolationQuality, rate: CGFloat) -> UIImage? {
        var resized: UIImage?
        let width = image.size.width * rate
        let height = image.size.height * rate
        
        UIGraphicsBeginImageContext(CGSize(width: width, height: height))
        let context = UIGraphicsGetCurrentContext()
        context?.interpolationQuality = quality
        image.draw(in: CGRect(x: 0, y: 0, width: width, height: height))
        
        resized = UIGraphicsGetImageFromCurrentImageContext()
        UIGraphicsEndImageContext()
        
        return resized
    }
    
    //‰∫åÁª¥Á†Å
    class func creatQRCode(content: String,
                           logo: UIImage? = nil,
                           logoFrame: CGRect = CGRect.zero,
                           size: CGFloat = -1,
                           highCorrection: Bool = false,
                           tintColor: UIColor? = nil) -> UIImage? {
        var retImage: UIImage? = nil
        var openHighCorrection = highCorrection
        
        // Â¶ÇÊûúË¶ÅÊ∑ªÂä†logoÊàñËÄÖÁªòÂà∂È¢úËâ≤ÔºåËá™Âä®ÂºÄÂêØÈ´òÂÆπÈîô
        if logo != nil || tintColor != nil {
            openHighCorrection = true
        }
        let correctionLevel = openHighCorrection ? "H" : "M"
        
        // ÁîüÊàê‰∫åÁª¥Á†ÅÂπ∂ËÆæÁΩÆÁ∫†ÈîôÁ∫ßÂà´
        let outputImage = qrCodeOutputImage(content: content,
                                            correctionLevel: correctionLevel)
        if let output = outputImage {
            // Ë∞ÉÊï¥Â∞∫ÂØ∏‰πãÂêéÁöÑ‰∫åÁª¥Á†Å
            retImage = adjustHDQRCode(outputImage: output,
                                      size:size)
        }
        
        // ‰∫åÁª¥Á†ÅÁùÄËâ≤
        if let mTintColor = tintColor {
            retImage = retImage?.cwModifyTintColor(tintColor: mTintColor)
        }
        
        // ‰∫åÁª¥Á†ÅÊ∑ªÂä†logo
        if let mLogo = logo {
            retImage = retImage?.cwAddLogoImage(image: mLogo,
                                                frame: logoFrame)
        }
        
        return retImage
    }
    
    
    ///   ÁîüÊàêÂéüÂßã‰∫åÁª¥Á†ÅCIImage
    ///   - content: ‰∫åÁª¥Á†ÅÂåÖÂê´ÁöÑÂÜÖÂÆπ
    ///   - correctionLevel: ‰∫åÁª¥Á†ÅÁ∫†ÈîôÁ∫ßÂà´ÔºåË∞ÉÈ´òÁ∫†ÈîôÁ∫ßÂà´ÂèØ‰ª•ÂæÄ‰∏äÈù¢Âä†‰∏Ä‰∏™Â§¥ÂÉèÊàñËÄÖÂèòËâ≤Ôºå‰ΩÜÊòØËØÜÂà´ÈÄüÂ∫¶‰πü‰ºöÈôç‰Ωé
    ///   - LÔºà‰ΩéÔºâ 7ÔºÖÁöÑÁ†ÅÂ≠óÂèØ‰ª•Ë¢´ÊÅ¢Â§ç„ÄÇ
    ///   - MÔºà‰∏≠Ôºâ 15ÔºÖÁöÑÁ†ÅÂ≠óÂèØ‰ª•Ë¢´ÊÅ¢Â§ç„ÄÇ
    ///   - QÔºàÂõõÂàÜÔºâ25ÔºÖÁöÑÁ†ÅÂ≠óÂèØ‰ª•Ë¢´ÊÅ¢Â§ç„ÄÇ
    ///   - HÔºàÈ´òÔºâ 30ÔºÖÁöÑÁ†ÅÂ≠óÂèØ‰ª•Ë¢´ÊÅ¢Â§ç„ÄÇ
    private class func qrCodeOutputImage(content: String,
                                         correctionLevel: String) -> CIImage? {
        // ÂàùÂßãÂåñfilter
        let data = content.data(using: .utf8)
        let qrFilter = CIFilter(name: "CIQRCodeGenerator")
        // ËÆæÁΩÆÂÜÖÂÆπ
        qrFilter?.setValue(data, forKey: "inputMessage")
        qrFilter?.setValue(correctionLevel, forKey: "inputCorrectionLevel")
        return qrFilter?.outputImage
    }
    
    /// Ë∞ÉÊï¥‰∫åÁª¥Á†ÅÁöÑÂ∞∫ÂØ∏Âπ∂ËøîÂõûÈ´òÊ∏ÖÂõæÁâá
    /// - Code:
    ///   - let transform = CGAffineTransform(scaleX: 5, y: 5)
    ///   - outputImage?.transformed(by: transform)
    ///
    /// - Parameters:
    ///   - outputImage: CIFilterÁîüÊàêÁöÑ‰∫åÁª¥Á†Å
    ///   - size: ÊîæÂ§ß‰πãÂêéÁöÑÂ∞∫ÂØ∏
    /// - Returns: ËøîÂõûË∞ÉÊï¥‰πãÂêéÁöÑÂõæÁâá
    private class func adjustHDQRCode(outputImage: CIImage,
                                      size: CGFloat) -> UIImage? {
        
        let integralRect: CGRect = outputImage.extent.integral
        // ËÆæÁΩÆÈªòËÆ§ÊîæÂ§ß5ÂÄç
        var scale: CGFloat = 5.0
        if size != -1 {
            // ÈúÄË¶ÅËÆ°ÁÆóÂá∫ÊúÄ‰Ω≥Áº©ÊîæÊØî‰æã
            scale = min(size/integralRect.width, size/integralRect.height)
        }
        
        let width = integralRect.width * scale
        let height = integralRect.height * scale
        
        let colorSpaceRef = CGColorSpaceCreateDeviceGray()
        let bitmapRef = CGContext(data: nil,
                                  width: Int(width),
                                  height: Int(height),
                                  bitsPerComponent: 8,
                                  bytesPerRow: 0,
                                  space: colorSpaceRef,
                                  bitmapInfo: CGImageAlphaInfo.none.rawValue)
        
        let context = CIContext(options: nil)
        
        //ÊîæÂ§ßÈáçÊñ∞ÁªòÂà∂
        if let bitmapImage = context.createCGImage(outputImage,
                                                   from: integralRect) {
            bitmapRef?.interpolationQuality = .none
            bitmapRef?.scaleBy(x: scale, y: scale)
            bitmapRef?.draw(bitmapImage, in: integralRect)
        }
        
        let scaledImage: CGImage! = bitmapRef?.makeImage()
        return UIImage(cgImage: scaledImage)
    }
    
    /// ÊîπÂèò‰∫åÁª¥Á†ÅÂõæÁâáÁöÑÂÉèÁ¥†ÁöÑÈ¢úËâ≤
    private func cwModifyTintColor(tintColor: UIColor) -> UIImage {
        
        // ÂøÖÈ°ªÂèØ‰ª•ËΩ¨Êç¢‰∏∫CGImage
        guard let mCgImage = self.cgImage else {
            return self
        }
        
        // Â∞ÜFloatÁ±ªÂûã‰øùÂ≠ò‰∏∫IntËøõË°åÂú∞ÂùÄÊìç‰Ωú
        let width = Int(self.size.width)
        let height = Int(self.size.height)
        
        // ÂàõÂª∫‰∏Ä‰∏™Â§ßÂ∞è‰∏∫ 4 * width * height ÁöÑÁºìÂ≠òÂå∫
        let bytesPerRow = width * 4
        let byteSize = width * height
        
        // ÂàùÂßãÂåñ‰∏Ä‰∏™ÊåáÈíàÁ±ªÂûãÂπ∂ÂàÜÈÖçÁ©∫Èó¥
        let rgbImageBuf = UnsafeMutablePointer<CWPixel>.allocate(capacity: byteSize)
        
        
        // ÂàùÂßãÂåñÁªòÂà∂ÔºåÈ¢úËâ≤Á©∫Èó¥Ë∑üÈöèËÆæÂ§á
        let colorSpaceRef = CGColorSpaceCreateDeviceRGB()
        // Áî®BGRAÂàõÂª∫‰∏Ä‰∏™‰ΩçÂõæ
        var bitmapInfo: UInt32 = CGBitmapInfo.byteOrder32Big.rawValue
        bitmapInfo = bitmapInfo | CGImageAlphaInfo.premultipliedLast.rawValue & CGBitmapInfo.alphaInfoMask.rawValue
        
        // ÂàõÂª∫‰ΩçÂõæ
        guard let context = CGContext(data: rgbImageBuf,
                                      width: width,
                                      height: height,
                                      bitsPerComponent: 8,
                                      bytesPerRow: bytesPerRow,
                                      space: colorSpaceRef,
                                      bitmapInfo: bitmapInfo)  else {
            return self
        }
        
        // ‰ΩøÁî®rgbImageBuf Â°´ÂÖÖ mCgImage
        context.draw(mCgImage, in: CGRect(origin: .zero, size: self.size))
        
        
        // ËøûÁª≠Â≠òÂÇ®ÁöÑÂÜÖÂ≠òÈõÜÂêà
        let bufferPointer = UnsafeMutableBufferPointer<CWPixel>(start: rgbImageBuf,
                                                                count: byteSize)
        
        // ÈáäÊîæÂàÜÈÖçÁöÑÁ©∫Èó¥
        //        rgbImageBuf.deallocate()
        
        //Ëé∑ÂèñÁ∫¢ÁªøËìùËâ≤ÂÄº
        var red: CGFloat = 0
        var green: CGFloat = 0
        var blue: CGFloat = 0
        var alpha: CGFloat = 0
        tintColor.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        
        // ÈÅçÂéÜÂÉèÁ¥†ÔºåÊîπÂèòÂÉèÁ¥†ÁÇπÈ¢úËâ≤
        for currentPixel in 0..<byteSize {
            var pixel = bufferPointer[currentPixel]
            if !pixel.isWhite {
                //ÂΩì‰∏çÊòØÁôΩËâ≤ÁöÑÊó∂ÂÄôÊâç‰ΩøÁî®
                pixel.red = UInt8(red * 255)
                pixel.green = UInt8(green * 255)
                pixel.blue = UInt8(blue * 255)
                //                pixel.alpha = UInt8(alpha * 255)
                let retPixel = pixel
                bufferPointer[currentPixel] = retPixel
            }
        }
        
        let inputColorSpace = CGColorSpaceCreateDeviceRGB()
        var inputBitmapInfo: UInt32 = CGBitmapInfo.byteOrder32Big.rawValue
        let inputBytesPerRow = width * 4
        
        inputBitmapInfo |= CGImageAlphaInfo.premultipliedLast.rawValue & CGBitmapInfo.alphaInfoMask.rawValue
        
        guard let imageContext = CGContext(data: bufferPointer.baseAddress,
                                           width: width,
                                           height: height,
                                           bitsPerComponent: 8,
                                           bytesPerRow: inputBytesPerRow,
                                           space: inputColorSpace,
                                           bitmapInfo: inputBitmapInfo,
                                           releaseCallback: nil,
                                           releaseInfo: nil) else {
            return self
        }
        
        guard let cgImage = imageContext.makeImage() else {
            return self
        }
        
        let image = UIImage(cgImage: cgImage)
        return image
    }
    
    /// Áªô‰∫åÁª¥Á†ÅÂõæÁâáÊ∑ªÂä†logo
    private func cwAddLogoImage(image: UIImage,
                                frame: CGRect) -> UIImage? {
        var resultImage: UIImage? = nil
        if frame != CGRect.zero {
            // ÂºÄÂßãÁªòÂà∂
            UIGraphicsBeginImageContext(self.size)
            //ÁªòÂà∂‰∫åÁª¥Á†ÅÂõæÁâá
            self.draw(in: CGRect.init(origin: CGPoint.zero,
                                      size:self.size))
            //ÁªòÂà∂Logo
            image.draw(in: frame)
            //Ëé∑ÂèñÁªòÂà∂‰πãÂêéÁöÑimage
            resultImage = UIGraphicsGetImageFromCurrentImageContext();
            //ÁªìÊùüÁªòÂà∂
            UIGraphicsEndImageContext();
        }
        return resultImage
    }
}
